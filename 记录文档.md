# 记录文档

## 数据库设计：

逻辑外键--->后端程序实现物理外键的功能

表之间的关系

注意字段、数据类型的对应问题

## 数据库连接池：

什么时候关闭：

一开始的思路:对JDBCUtils进行监听，如果超过规定时间没有使用该工具类，就关闭(待实现)    ***定时器***

1. 将MyConnectionPool的字段改为private，使用getter和setter方法来访问。
2. 将MyConnection实现AutoCloseable接口，以方便使用try-with-resources语言来确保连接被正确关闭。
3. 将MyConnection的isUsed字段改为private，并提供isUsed()方法来获取该字段的值。
4. 将MyConnectionPool的getConnection()方法中的循环改为foreach循环。
5. 将MyConnectionPool的release()方法中的变量count改为freeCount，以避免与类的静态字符串段count混杂。
6. 在MyConnectionPool的send()方法中使用try-with-resources语句来确保语句和连接被正确关闭。
7. 在MyConnectionPool的send()方法中使用PreparedStatement代替Statement，并使用setFetchSize()方法设置每次从数据库中查询的行数。
8. 在MyConnectionPool的send()方法中，当PreparedStatement的executeQuery()方法返回的ResultSet不为空时，关闭ResultSet。
9. 在MyConnectionPool的send()方法中，将PreparedStatement的结果集合类型设置为TYPE_FORWARD_ONLY，以方便只向前遍历结果集合。
10. 在MyConnectionPool的send()方法中，将PreparedStatement的结果集可以更新设置为false，以尽可能减少资源使用

## 事务管理：

service层增删改操作：开启 提交 回滚X---->curdutils

用日志来记录事务？

## 重定向

`request.getRequestDispatcher("/login.html").forward(request, response)` 是在服务器端内部进行请求的转发，将当前的 request 和 response 对象传递给另一个 servlet 或 JSP 页面。转发不改变 URL，浏览器的地址栏中仍然显示原来的 URL，因此用户无法看到实际的页面路径。这种方式常用于处理用户请求并在服务端处理完毕后转发到另一个页面。

而 `response.sendRedirect(request.getContextPath() + "/login.html")` 是在客户端进行请求的重定向，服务器将一个特殊的响应发送给浏览器，告诉它要加载新的 URL 地址。在此过程中，浏览器的地址栏将显示重定向后的 URL。这种方式常用于在登录后将用户重定向到另一个页面。

因此，如果您需要在服务器内部进行请求的转发，可以使用 `request.getRequestDispatcher().forward()` 方法；如果您需要在客户端进行请求的重定向，则可以使用 `response.sendRedirect()` 方法。

## 枚举

在使用时，可以将枚举类型值通过这种方式转换成数据库中的值：

```
爪哇复制代码Order order = new Order();
order.setStatus(OrderStatus.PAID);
int statusValue = order.getStatus().getValue();
```

或者作者将数据库中的值通过 fromValue 方法转换成枚举类型：

```
爪哇复制代码int statusValueFromDB = resultSet.getInt("status");
OrderStatus status = OrderStatus.fromValue(statusValueFromDB);
```

## 在确认购买界面选择收货地址

1. 在确认购买界面中，添加一个选择收货地址的按钮或链接，点击后跳转到选择收货地址的页面。
2. 在选择收货地址的页面中，显示当前用户所有的收货地址列表。可以使用`AddressDao`中的`getAddressListByUserId()`方法查询出当前用户的所有收货地址，并将其显示在页面上。
3. 在页面中，为每个收货地址添加一个选择按钮或复选框，用户可以勾选其中一个地址作为收货地址。
4. 当用户勾选了一个收货地址后，点击确认按钮或链接返回到确认购买界面。此时，将用户选择的收货地址信息存储到订单表中，作为订单的收货地址信息。
5. 在确认购买界面中，显示用户选择的收货地址信息。可以使用`AddressDao`中的`getAddressById()`方法查询出用户选择的收货地址信息，并将其显示在页面上。

## MyFile

MultipartFile是Spring框架提供的一个接口，用于处理上传的文件。如果不使用Spring框架，可以通过Java原生的文件上传方式来实现类似的功能。

下面是一种实现方式：

1. 创建一个类来表示上传的文件，包括文件名、文件类型、文件大小和文件内容等属性。例如：

```
javaCopy codepublic class MyFile {
    private String fileName;
    private String contentType;
    private long size;
    private byte[] content;

    // 构造函数和getter/setter方法
}
```

1. 创建一个Servlet来处理上传的文件，可以在Servlet中使用Java原生的文件上传方式来读取上传的文件数据，并将数据保存到MyFile对象中。例如：

```
javaCopy code@WebServlet("/upload")
@MultipartConfig
public class UploadServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        MyFile myFile = new MyFile();
        Part filePart = request.getPart("file"); // 获取上传的文件数据
        myFile.setFileName(filePart.getSubmittedFileName()); // 设置文件名
        myFile.setContentType(filePart.getContentType()); // 设置文件类型
        myFile.setSize(filePart.getSize()); // 设置文件大小
        myFile.setContent(filePart.getInputStream().readAllBytes()); // 设置文件内容
        // 处理上传的文件数据
    }
}
```

1. 在前端页面中使用HTML的表单来上传文件。例如：

```
htmlCopy code<form action="upload" method="post" enctype="multipart/form-data">
    <input type="file" name="file">
    <button type="submit">上传</button>
</form>
```

上面的代码使用了Java原生的Servlet和HTML表单来实现上传文件的功能，虽然没有使用Spring框架的MultipartFile接口，但实现的效果是类似的。

## Part API

| 方法                    | 描述                                   | 返回值               |
| ----------------------- | -------------------------------------- | -------------------- |
| write(String fileName)  | 将文件内容写入指定的磁盘位置           | void                 |
| getSize()               | 获取上传文件的大小                     | long                 |
| getName()               | 获取file控件的name属性                 | String               |
| getHeader(String name)  | 获取指定请求头                         | String               |
| getHeaderNames()        | 获取所有请求头的名称                   | String               |
| getHeaders(String name) | 获取指定header名称的集合数据           | Collection< String > |
| getContentType()        | 获取文件MIME类型                       | String               |
| getInputStream()        | 获取输入流用于检索文件的内容           | InputStream          |
| delete()                | 删除Part数据和临时目录数据,默认会删除  | void                 |
| getSubmittedFileName()  | 获取上传文件名Servlet3.1 Tomcat8.0实现 | String               |

## 月销量

```sql
SELECT count( 1 ) FROM tb_commodity_order WHERE create_time >= date_add(curdate(), INTERVAL - DAY ( curdate()) + 1 DAY ) and commodity_id = 1
```

在不使用WebSocket的情况下现实Web端的私聊功能比较困难，因为HTTP是一种无状态的协议，每个请求都是独立的，不能保持连接。因此，现实需要在客户端和服务器上进行私聊功能间建立长连接，以便客端能够接收服务器发送的消息。

一种实际现在方法是使用AJAX轮询（AJAX Long Polling）技术，这种技术是一种模拟长连接的方式。客户端通过发送一个长挂起的HTTP请求来建立连接，服务器在有新消息时返回响应，否则保持连接处于挂起状态，直到有新消息到才返回响应。客户端在接收到服务器响应后，再立即发送新的请求建立新的连接，以这样循环下去。

实际私聊功能的具体步骤如下：

1. 客户端发起私聊请求时，将消息发送给服务器，并指定接收者的用户名。
2. 服务器接收到私聊请求后，将消息转发给指定的接收者，同时将消息保存在数据库中，以方便后续查询。
3. 客户端定时发送轮询请求，查询是否有新的私聊信息。
4. 服务器查询数据库，如果有新的私聊消息，则返回给客户端响应，客户端将新消息添加到聊天窗口中。

注意，AJAX轮询技术的实际需要注意以下几个问题：

1. 客户端需要定时发送轮询请求，否则连接可能会被服务器关闭。
2. 服务器需要在长时间没有新消息到达时，关闭链接，以免耗费大量的资源。
3. 长连接会占用服务器的资源，因此需要限制连接的数量或使用心跳机制造来维持连接
